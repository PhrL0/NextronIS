/* tslint:disable */
/* eslint-disable */
/**
 * Nextron API
 * API for managing machines, users, and AI models in Nextron
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityLogGet200Response
 */
export interface ActivityLogGet200Response {
    /**
     * 
     * @type {Array<ActivityLogGet200ResponseActivityLogsInner>}
     * @memberof ActivityLogGet200Response
     */
    'activity_logs': Array<ActivityLogGet200ResponseActivityLogsInner>;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ActivityLogGet200ResponseActivityLogsInner
 */
export interface ActivityLogGet200ResponseActivityLogsInner {
    /**
     * 
     * @type {number}
     * @memberof ActivityLogGet200ResponseActivityLogsInner
     */
    'log_id': number;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogGet200ResponseActivityLogsInner
     */
    'machine_id': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogGet200ResponseActivityLogsInner
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogGet200ResponseActivityLogsInner
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface ActivityLogIdGet200Response
 */
export interface ActivityLogIdGet200Response {
    /**
     * 
     * @type {ActivityLogGet200ResponseActivityLogsInner}
     * @memberof ActivityLogIdGet200Response
     */
    'activity_log': ActivityLogGet200ResponseActivityLogsInner;
}
/**
 * 
 * @export
 * @interface ActivityLogPost200Response
 */
export interface ActivityLogPost200Response {
    /**
     * 
     * @type {number}
     * @memberof ActivityLogPost200Response
     */
    'log_id': number;
}
/**
 * 
 * @export
 * @interface ActivityLogPostRequest
 */
export interface ActivityLogPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ActivityLogPostRequest
     */
    'machine_id': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogPostRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogPostRequest
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface AiPost200Response
 */
export interface AiPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AiPost200Response
     */
    'response': string;
}
/**
 * 
 * @export
 * @interface AiPostRequest
 */
export interface AiPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AiPostRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AttributeGet200Response
 */
export interface AttributeGet200Response {
    /**
     * 
     * @type {Array<AttributeGet200ResponseAttributesInner>}
     * @memberof AttributeGet200Response
     */
    'attributes': Array<AttributeGet200ResponseAttributesInner>;
    /**
     * 
     * @type {number}
     * @memberof AttributeGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof AttributeGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof AttributeGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface AttributeGet200ResponseAttributesInner
 */
export interface AttributeGet200ResponseAttributesInner {
    /**
     * 
     * @type {number}
     * @memberof AttributeGet200ResponseAttributesInner
     */
    'attribute_id': number;
    /**
     * 
     * @type {string}
     * @memberof AttributeGet200ResponseAttributesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeGet200ResponseAttributesInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeGet200ResponseAttributesInner
     */
    'unit': string | null;
}
/**
 * 
 * @export
 * @interface AttributeIdGet200Response
 */
export interface AttributeIdGet200Response {
    /**
     * 
     * @type {AttributeGet200ResponseAttributesInner}
     * @memberof AttributeIdGet200Response
     */
    'attribute': AttributeGet200ResponseAttributesInner;
}
/**
 * 
 * @export
 * @interface AttributePost200Response
 */
export interface AttributePost200Response {
    /**
     * 
     * @type {number}
     * @memberof AttributePost200Response
     */
    'attribute_id': number;
}
/**
 * 
 * @export
 * @interface AttributePostRequest
 */
export interface AttributePostRequest {
    /**
     * 
     * @type {string}
     * @memberof AttributePostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttributePostRequest
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AttributePostRequest
     */
    'unit': string | null;
}
/**
 * 
 * @export
 * @interface AuthLoginPost200Response
 */
export interface AuthLoginPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface AuthLoginPost401Response
 */
export interface AuthLoginPost401Response {
    /**
     * 
     * @type {number}
     * @memberof AuthLoginPost401Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AuthLoginPostRequest
 */
export interface AuthLoginPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthRegisterPost201Response
 */
export interface AuthRegisterPost201Response {
    /**
     * 
     * @type {number}
     * @memberof AuthRegisterPost201Response
     */
    'user_id': number;
}
/**
 * 
 * @export
 * @interface AuthRegisterPostRequest
 */
export interface AuthRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LocateGet200Response
 */
export interface LocateGet200Response {
    /**
     * 
     * @type {Array<LocateGet200ResponseLocationsInner>}
     * @memberof LocateGet200Response
     */
    'locations': Array<LocateGet200ResponseLocationsInner>;
    /**
     * 
     * @type {number}
     * @memberof LocateGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof LocateGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof LocateGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface LocateGet200ResponseLocationsInner
 */
export interface LocateGet200ResponseLocationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'location_id': number;
    /**
     * 
     * @type {string}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'zip': string;
    /**
     * 
     * @type {number}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'latitude': number | null;
    /**
     * 
     * @type {number}
     * @memberof LocateGet200ResponseLocationsInner
     */
    'longitude': number | null;
}
/**
 * 
 * @export
 * @interface LocateIdGet200Response
 */
export interface LocateIdGet200Response {
    /**
     * 
     * @type {LocateGet200ResponseLocationsInner}
     * @memberof LocateIdGet200Response
     */
    'location': LocateGet200ResponseLocationsInner;
}
/**
 * 
 * @export
 * @interface LocatePostRequest
 */
export interface LocatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof LocatePostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocatePostRequest
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof LocatePostRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof LocatePostRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof LocatePostRequest
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof LocatePostRequest
     */
    'zip': string;
    /**
     * 
     * @type {number}
     * @memberof LocatePostRequest
     */
    'latitude': number | null;
    /**
     * 
     * @type {number}
     * @memberof LocatePostRequest
     */
    'longitude': number | null;
}
/**
 * 
 * @export
 * @interface MachineGet200Response
 */
export interface MachineGet200Response {
    /**
     * 
     * @type {Array<MachineGet200ResponseMachinesInner>}
     * @memberof MachineGet200Response
     */
    'machines': Array<MachineGet200ResponseMachinesInner>;
    /**
     * 
     * @type {number}
     * @memberof MachineGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof MachineGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof MachineGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface MachineGet200ResponseMachinesInner
 */
export interface MachineGet200ResponseMachinesInner {
    /**
     * 
     * @type {number}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'machine_id': number;
    /**
     * 
     * @type {string}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'machine_type_id': number;
    /**
     * 
     * @type {number}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'location_id': number;
    /**
     * 
     * @type {string}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'last_updated': string;
    /**
     * 
     * @type {string}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'created_at': string;
    /**
     * 
     * @type {LocateGet200ResponseLocationsInner}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'location': LocateGet200ResponseLocationsInner;
    /**
     * 
     * @type {MachineGet200ResponseMachinesInnerMachineType}
     * @memberof MachineGet200ResponseMachinesInner
     */
    'machine_type': MachineGet200ResponseMachinesInnerMachineType;
}
/**
 * 
 * @export
 * @interface MachineGet200ResponseMachinesInnerMachineType
 */
export interface MachineGet200ResponseMachinesInnerMachineType {
    /**
     * 
     * @type {number}
     * @memberof MachineGet200ResponseMachinesInnerMachineType
     */
    'machine_type_id': number;
    /**
     * 
     * @type {string}
     * @memberof MachineGet200ResponseMachinesInnerMachineType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MachineGet200ResponseMachinesInnerMachineType
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface MachineIdGet200Response
 */
export interface MachineIdGet200Response {
    /**
     * 
     * @type {MachineIdGet200ResponseMachine}
     * @memberof MachineIdGet200Response
     */
    'machine': MachineIdGet200ResponseMachine;
}
/**
 * 
 * @export
 * @interface MachineIdGet200ResponseMachine
 */
export interface MachineIdGet200ResponseMachine {
    /**
     * 
     * @type {number}
     * @memberof MachineIdGet200ResponseMachine
     */
    'machine_id': number;
    /**
     * 
     * @type {string}
     * @memberof MachineIdGet200ResponseMachine
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MachineIdGet200ResponseMachine
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof MachineIdGet200ResponseMachine
     */
    'machine_type_id': number;
    /**
     * 
     * @type {number}
     * @memberof MachineIdGet200ResponseMachine
     */
    'location_id': number;
    /**
     * 
     * @type {string}
     * @memberof MachineIdGet200ResponseMachine
     */
    'last_updated': string;
    /**
     * 
     * @type {string}
     * @memberof MachineIdGet200ResponseMachine
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface MachinePost200Response
 */
export interface MachinePost200Response {
    /**
     * 
     * @type {number}
     * @memberof MachinePost200Response
     */
    'machine_id': number;
}
/**
 * 
 * @export
 * @interface MachinePostRequest
 */
export interface MachinePostRequest {
    /**
     * 
     * @type {string}
     * @memberof MachinePostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MachinePostRequest
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof MachinePostRequest
     */
    'machine_type_id': number;
    /**
     * 
     * @type {number}
     * @memberof MachinePostRequest
     */
    'location_id': number;
}
/**
 * 
 * @export
 * @interface MachineTypeGet200Response
 */
export interface MachineTypeGet200Response {
    /**
     * 
     * @type {Array<MachineGet200ResponseMachinesInnerMachineType>}
     * @memberof MachineTypeGet200Response
     */
    'machine_types': Array<MachineGet200ResponseMachinesInnerMachineType>;
    /**
     * 
     * @type {number}
     * @memberof MachineTypeGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof MachineTypeGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof MachineTypeGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface MachineTypeIdGet200Response
 */
export interface MachineTypeIdGet200Response {
    /**
     * 
     * @type {MachineGet200ResponseMachinesInnerMachineType}
     * @memberof MachineTypeIdGet200Response
     */
    'machine_type': MachineGet200ResponseMachinesInnerMachineType;
}
/**
 * 
 * @export
 * @interface MachineTypePostRequest
 */
export interface MachineTypePostRequest {
    /**
     * 
     * @type {string}
     * @memberof MachineTypePostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MachineTypePostRequest
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface PermissionGet200Response
 */
export interface PermissionGet200Response {
    /**
     * 
     * @type {Array<PermissionGet200ResponsePermissionsInner>}
     * @memberof PermissionGet200Response
     */
    'permissions': Array<PermissionGet200ResponsePermissionsInner>;
    /**
     * 
     * @type {number}
     * @memberof PermissionGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PermissionGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PermissionGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface PermissionGet200ResponsePermissionsInner
 */
export interface PermissionGet200ResponsePermissionsInner {
    /**
     * 
     * @type {number}
     * @memberof PermissionGet200ResponsePermissionsInner
     */
    'permission_id': number;
    /**
     * 
     * @type {string}
     * @memberof PermissionGet200ResponsePermissionsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionGet200ResponsePermissionsInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface PermissionIdGet200Response
 */
export interface PermissionIdGet200Response {
    /**
     * 
     * @type {PermissionGet200ResponsePermissionsInner}
     * @memberof PermissionIdGet200Response
     */
    'permission': PermissionGet200ResponsePermissionsInner;
}
/**
 * 
 * @export
 * @interface PermissionPost200Response
 */
export interface PermissionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof PermissionPost200Response
     */
    'permission_id': string;
}
/**
 * 
 * @export
 * @interface ReadingGet200Response
 */
export interface ReadingGet200Response {
    /**
     * 
     * @type {Array<ReadingGet200ResponseReadingsInner>}
     * @memberof ReadingGet200Response
     */
    'readings': Array<ReadingGet200ResponseReadingsInner>;
    /**
     * 
     * @type {number}
     * @memberof ReadingGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ReadingGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ReadingGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ReadingGet200ResponseReadingsInner
 */
export interface ReadingGet200ResponseReadingsInner {
    /**
     * 
     * @type {number}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'reading_id': number;
    /**
     * 
     * @type {string}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'recorded_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'day_of_week': ReadingGet200ResponseReadingsInnerDayOfWeekEnum;
    /**
     * 
     * @type {string}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'status': ReadingGet200ResponseReadingsInnerStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'machine_id': number;
    /**
     * 
     * @type {number}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'attribute_id': number;
    /**
     * 
     * @type {string}
     * @memberof ReadingGet200ResponseReadingsInner
     */
    'attribute_value': string;
}

export const ReadingGet200ResponseReadingsInnerDayOfWeekEnum = {
    Sunday: 'SUNDAY',
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY'
} as const;

export type ReadingGet200ResponseReadingsInnerDayOfWeekEnum = typeof ReadingGet200ResponseReadingsInnerDayOfWeekEnum[keyof typeof ReadingGet200ResponseReadingsInnerDayOfWeekEnum];
export const ReadingGet200ResponseReadingsInnerStatusEnum = {
    Strange: 'STRANGE',
    Normal: 'NORMAL',
    Alert: 'ALERT',
    Dangerous: 'DANGEROUS',
    Critical: 'CRITICAL'
} as const;

export type ReadingGet200ResponseReadingsInnerStatusEnum = typeof ReadingGet200ResponseReadingsInnerStatusEnum[keyof typeof ReadingGet200ResponseReadingsInnerStatusEnum];

/**
 * 
 * @export
 * @interface ReadingIdGet200Response
 */
export interface ReadingIdGet200Response {
    /**
     * 
     * @type {ReadingGet200ResponseReadingsInner}
     * @memberof ReadingIdGet200Response
     */
    'reading': ReadingGet200ResponseReadingsInner;
}
/**
 * 
 * @export
 * @interface ReadingPost200Response
 */
export interface ReadingPost200Response {
    /**
     * 
     * @type {number}
     * @memberof ReadingPost200Response
     */
    'reading_id': number;
}
/**
 * 
 * @export
 * @interface ReadingPostRequest
 */
export interface ReadingPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ReadingPostRequest
     */
    'recorded_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReadingPostRequest
     */
    'day_of_week': ReadingPostRequestDayOfWeekEnum;
    /**
     * 
     * @type {string}
     * @memberof ReadingPostRequest
     */
    'status': ReadingPostRequestStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ReadingPostRequest
     */
    'machine_id': number;
    /**
     * 
     * @type {number}
     * @memberof ReadingPostRequest
     */
    'attribute_id': number;
    /**
     * 
     * @type {string}
     * @memberof ReadingPostRequest
     */
    'attribute_value': string;
}

export const ReadingPostRequestDayOfWeekEnum = {
    Sunday: 'SUNDAY',
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY'
} as const;

export type ReadingPostRequestDayOfWeekEnum = typeof ReadingPostRequestDayOfWeekEnum[keyof typeof ReadingPostRequestDayOfWeekEnum];
export const ReadingPostRequestStatusEnum = {
    Strange: 'STRANGE',
    Normal: 'NORMAL',
    Alert: 'ALERT',
    Dangerous: 'DANGEROUS',
    Critical: 'CRITICAL'
} as const;

export type ReadingPostRequestStatusEnum = typeof ReadingPostRequestStatusEnum[keyof typeof ReadingPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface RoleGet200Response
 */
export interface RoleGet200Response {
    /**
     * 
     * @type {Array<RoleGet200ResponseRolesInner>}
     * @memberof RoleGet200Response
     */
    'roles': Array<RoleGet200ResponseRolesInner>;
    /**
     * 
     * @type {number}
     * @memberof RoleGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof RoleGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof RoleGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface RoleGet200ResponseRolesInner
 */
export interface RoleGet200ResponseRolesInner {
    /**
     * 
     * @type {number}
     * @memberof RoleGet200ResponseRolesInner
     */
    'role_id': number;
    /**
     * 
     * @type {string}
     * @memberof RoleGet200ResponseRolesInner
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof RoleGet200ResponseRolesInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface RoleIdGet200Response
 */
export interface RoleIdGet200Response {
    /**
     * 
     * @type {RoleGet200ResponseRolesInner}
     * @memberof RoleIdGet200Response
     */
    'role': RoleGet200ResponseRolesInner;
}
/**
 * 
 * @export
 * @interface RolePost200Response
 */
export interface RolePost200Response {
    /**
     * 
     * @type {string}
     * @memberof RolePost200Response
     */
    'user_role_id': string;
}
/**
 * 
 * @export
 * @interface UserGet200Response
 */
export interface UserGet200Response {
    /**
     * 
     * @type {Array<UserGet200ResponseUsersInner>}
     * @memberof UserGet200Response
     */
    'users': Array<UserGet200ResponseUsersInner>;
    /**
     * 
     * @type {number}
     * @memberof UserGet200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof UserGet200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof UserGet200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface UserGet200ResponseUsersInner
 */
export interface UserGet200ResponseUsersInner {
    /**
     * 
     * @type {number}
     * @memberof UserGet200ResponseUsersInner
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof UserGet200ResponseUsersInner
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserGet200ResponseUsersInner
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserGet200ResponseUsersInner
     */
    'password_hash': string;
    /**
     * 
     * @type {string}
     * @memberof UserGet200ResponseUsersInner
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserGet200ResponseUsersInner
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface UserIdGet200Response
 */
export interface UserIdGet200Response {
    /**
     * 
     * @type {UserGet200ResponseUsersInner}
     * @memberof UserIdGet200Response
     */
    'user': UserGet200ResponseUsersInner;
}
/**
 * 
 * @export
 * @interface UserIdPutRequest
 */
export interface UserIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof UserIdPutRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserIdPutRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserIdPutRequest
     */
    'password_hash'?: string;
}
/**
 * 
 * @export
 * @interface UserRolePost201Response
 */
export interface UserRolePost201Response {
    /**
     * 
     * @type {UserRolePost201ResponseUserRole}
     * @memberof UserRolePost201Response
     */
    'userRole': UserRolePost201ResponseUserRole;
}
/**
 * 
 * @export
 * @interface UserRolePost201ResponseUserRole
 */
export interface UserRolePost201ResponseUserRole {
    /**
     * 
     * @type {number}
     * @memberof UserRolePost201ResponseUserRole
     */
    'user_role_id': number;
    /**
     * 
     * @type {number}
     * @memberof UserRolePost201ResponseUserRole
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof UserRolePost201ResponseUserRole
     */
    'role_id': number;
}
/**
 * 
 * @export
 * @interface UserRolePostRequest
 */
export interface UserRolePostRequest {
    /**
     * 
     * @type {number}
     * @memberof UserRolePostRequest
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof UserRolePostRequest
     */
    'role_id': number;
}

/**
 * ActivityLogApi - axios parameter creator
 * @export
 */
export const ActivityLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all activity logs
         * @param {string} [sort] 
         * @param {ActivityLogGetOrderEnum} [order] 
         * @param {ActivityLogGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLogGet: async (sort?: string, order?: ActivityLogGetOrderEnum, direction?: ActivityLogGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get activity log by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLogIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activityLogIdGet', 'id', id)
            const localVarPath = `/activity-log/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a activity log
         * @param {ActivityLogPostRequest} activityLogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLogPost: async (activityLogPostRequest: ActivityLogPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityLogPostRequest' is not null or undefined
            assertParamExists('activityLogPost', 'activityLogPostRequest', activityLogPostRequest)
            const localVarPath = `/activity-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityLogPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogApi - functional programming interface
 * @export
 */
export const ActivityLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityLogApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all activity logs
         * @param {string} [sort] 
         * @param {ActivityLogGetOrderEnum} [order] 
         * @param {ActivityLogGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityLogGet(sort?: string, order?: ActivityLogGetOrderEnum, direction?: ActivityLogGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityLogGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityLogGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogApi.activityLogGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get activity log by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityLogIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityLogIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityLogIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogApi.activityLogIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a activity log
         * @param {ActivityLogPostRequest} activityLogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityLogPost(activityLogPostRequest: ActivityLogPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityLogPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityLogPost(activityLogPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogApi.activityLogPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityLogApi - factory interface
 * @export
 */
export const ActivityLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityLogApiFp(configuration)
    return {
        /**
         * Get all activity logs
         * @param {string} [sort] 
         * @param {ActivityLogGetOrderEnum} [order] 
         * @param {ActivityLogGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLogGet(sort?: string, order?: ActivityLogGetOrderEnum, direction?: ActivityLogGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ActivityLogGet200Response> {
            return localVarFp.activityLogGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get activity log by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLogIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ActivityLogIdGet200Response> {
            return localVarFp.activityLogIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a activity log
         * @param {ActivityLogPostRequest} activityLogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLogPost(activityLogPostRequest: ActivityLogPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ActivityLogPost200Response> {
            return localVarFp.activityLogPost(activityLogPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityLogApi - object-oriented interface
 * @export
 * @class ActivityLogApi
 * @extends {BaseAPI}
 */
export class ActivityLogApi extends BaseAPI {
    /**
     * Get all activity logs
     * @param {string} [sort] 
     * @param {ActivityLogGetOrderEnum} [order] 
     * @param {ActivityLogGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public activityLogGet(sort?: string, order?: ActivityLogGetOrderEnum, direction?: ActivityLogGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ActivityLogApiFp(this.configuration).activityLogGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get activity log by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public activityLogIdGet(id: number, options?: RawAxiosRequestConfig) {
        return ActivityLogApiFp(this.configuration).activityLogIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a activity log
     * @param {ActivityLogPostRequest} activityLogPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public activityLogPost(activityLogPostRequest: ActivityLogPostRequest, options?: RawAxiosRequestConfig) {
        return ActivityLogApiFp(this.configuration).activityLogPost(activityLogPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ActivityLogGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ActivityLogGetOrderEnum = typeof ActivityLogGetOrderEnum[keyof typeof ActivityLogGetOrderEnum];
/**
 * @export
 */
export const ActivityLogGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ActivityLogGetDirectionEnum = typeof ActivityLogGetDirectionEnum[keyof typeof ActivityLogGetDirectionEnum];


/**
 * AiApi - axios parameter creator
 * @export
 */
export const AiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get AI configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ai/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Answer a question using AI
         * @param {AiPostRequest} aiPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiPost: async (aiPostRequest: AiPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aiPostRequest' is not null or undefined
            assertParamExists('aiPost', 'aiPostRequest', aiPostRequest)
            const localVarPath = `/ai/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aiPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AiApi - functional programming interface
 * @export
 */
export const AiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AiApiAxiosParamCreator(configuration)
    return {
        /**
         * Get AI configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiApi.aiGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Answer a question using AI
         * @param {AiPostRequest} aiPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiPost(aiPostRequest: AiPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiPost(aiPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiApi.aiPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AiApi - factory interface
 * @export
 */
export const AiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AiApiFp(configuration)
    return {
        /**
         * Get AI configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.aiGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Answer a question using AI
         * @param {AiPostRequest} aiPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiPost(aiPostRequest: AiPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AiPost200Response> {
            return localVarFp.aiPost(aiPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AiApi - object-oriented interface
 * @export
 * @class AiApi
 * @extends {BaseAPI}
 */
export class AiApi extends BaseAPI {
    /**
     * Get AI configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AiApi
     */
    public aiGet(options?: RawAxiosRequestConfig) {
        return AiApiFp(this.configuration).aiGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Answer a question using AI
     * @param {AiPostRequest} aiPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AiApi
     */
    public aiPost(aiPostRequest: AiPostRequest, options?: RawAxiosRequestConfig) {
        return AiApiFp(this.configuration).aiPost(aiPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AttributeApi - axios parameter creator
 * @export
 */
export const AttributeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all attributes
         * @param {string} [sort] 
         * @param {AttributeGetOrderEnum} [order] 
         * @param {AttributeGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributeGet: async (sort?: string, order?: AttributeGetOrderEnum, direction?: AttributeGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attribute/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get attribute by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributeIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attributeIdGet', 'id', id)
            const localVarPath = `/attribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new attribute
         * @param {AttributePostRequest} attributePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributePost: async (attributePostRequest: AttributePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributePostRequest' is not null or undefined
            assertParamExists('attributePost', 'attributePostRequest', attributePostRequest)
            const localVarPath = `/attribute/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attributePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttributeApi - functional programming interface
 * @export
 */
export const AttributeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttributeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all attributes
         * @param {string} [sort] 
         * @param {AttributeGetOrderEnum} [order] 
         * @param {AttributeGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attributeGet(sort?: string, order?: AttributeGetOrderEnum, direction?: AttributeGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attributeGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttributeApi.attributeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get attribute by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attributeIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attributeIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttributeApi.attributeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register new attribute
         * @param {AttributePostRequest} attributePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attributePost(attributePostRequest: AttributePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attributePost(attributePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttributeApi.attributePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttributeApi - factory interface
 * @export
 */
export const AttributeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttributeApiFp(configuration)
    return {
        /**
         * Get all attributes
         * @param {string} [sort] 
         * @param {AttributeGetOrderEnum} [order] 
         * @param {AttributeGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributeGet(sort?: string, order?: AttributeGetOrderEnum, direction?: AttributeGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<AttributeGet200Response> {
            return localVarFp.attributeGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get attribute by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributeIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<AttributeIdGet200Response> {
            return localVarFp.attributeIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new attribute
         * @param {AttributePostRequest} attributePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributePost(attributePostRequest: AttributePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AttributePost200Response> {
            return localVarFp.attributePost(attributePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttributeApi - object-oriented interface
 * @export
 * @class AttributeApi
 * @extends {BaseAPI}
 */
export class AttributeApi extends BaseAPI {
    /**
     * Get all attributes
     * @param {string} [sort] 
     * @param {AttributeGetOrderEnum} [order] 
     * @param {AttributeGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeApi
     */
    public attributeGet(sort?: string, order?: AttributeGetOrderEnum, direction?: AttributeGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return AttributeApiFp(this.configuration).attributeGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get attribute by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeApi
     */
    public attributeIdGet(id: number, options?: RawAxiosRequestConfig) {
        return AttributeApiFp(this.configuration).attributeIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new attribute
     * @param {AttributePostRequest} attributePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeApi
     */
    public attributePost(attributePostRequest: AttributePostRequest, options?: RawAxiosRequestConfig) {
        return AttributeApiFp(this.configuration).attributePost(attributePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AttributeGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AttributeGetOrderEnum = typeof AttributeGetOrderEnum[keyof typeof AttributeGetOrderEnum];
/**
 * @export
 */
export const AttributeGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AttributeGetDirectionEnum = typeof AttributeGetDirectionEnum[keyof typeof AttributeGetDirectionEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login user
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (authLoginPostRequest: AuthLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginPostRequest' is not null or undefined
            assertParamExists('authLoginPost', 'authLoginPostRequest', authLoginPostRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (authRegisterPostRequest: AuthRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRegisterPostRequest' is not null or undefined
            assertParamExists('authRegisterPost', 'authRegisterPostRequest', authRegisterPostRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Login user
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(authLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegisterPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(authRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Login user
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLoginPost200Response> {
            return localVarFp.authLoginPost(authLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegisterPost201Response> {
            return localVarFp.authRegisterPost(authRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Login user
     * @param {AuthLoginPostRequest} authLoginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(authLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user
     * @param {AuthRegisterPostRequest} authRegisterPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(authRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all locations
         * @param {string} [sort] 
         * @param {LocateGetOrderEnum} [order] 
         * @param {LocateGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locateGet: async (sort?: string, order?: LocateGetOrderEnum, direction?: LocateGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get location by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locateIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('locateIdGet', 'id', id)
            const localVarPath = `/locate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new location
         * @param {LocatePostRequest} locatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locatePost: async (locatePostRequest: LocatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locatePostRequest' is not null or undefined
            assertParamExists('locatePost', 'locatePostRequest', locatePostRequest)
            const localVarPath = `/locate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all locations
         * @param {string} [sort] 
         * @param {LocateGetOrderEnum} [order] 
         * @param {LocateGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locateGet(sort?: string, order?: LocateGetOrderEnum, direction?: LocateGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locateGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get location by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locateIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocateIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locateIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locateIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new location
         * @param {LocatePostRequest} locatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locatePost(locatePostRequest: LocatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locatePost(locatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * Get all locations
         * @param {string} [sort] 
         * @param {LocateGetOrderEnum} [order] 
         * @param {LocateGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locateGet(sort?: string, order?: LocateGetOrderEnum, direction?: LocateGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<LocateGet200Response> {
            return localVarFp.locateGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get location by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locateIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<LocateIdGet200Response> {
            return localVarFp.locateIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new location
         * @param {LocatePostRequest} locatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locatePost(locatePostRequest: LocatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locatePost(locatePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * Get all locations
     * @param {string} [sort] 
     * @param {LocateGetOrderEnum} [order] 
     * @param {LocateGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locateGet(sort?: string, order?: LocateGetOrderEnum, direction?: LocateGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locateGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get location by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locateIdGet(id: number, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locateIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new location
     * @param {LocatePostRequest} locatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locatePost(locatePostRequest: LocatePostRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locatePost(locatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const LocateGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LocateGetOrderEnum = typeof LocateGetOrderEnum[keyof typeof LocateGetOrderEnum];
/**
 * @export
 */
export const LocateGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LocateGetDirectionEnum = typeof LocateGetDirectionEnum[keyof typeof LocateGetDirectionEnum];


/**
 * MachineApi - axios parameter creator
 * @export
 */
export const MachineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all machines
         * @param {string} [sort] 
         * @param {MachineGetOrderEnum} [order] 
         * @param {MachineGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineGet: async (sort?: string, order?: MachineGetOrderEnum, direction?: MachineGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machine/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get machine by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machineIdGet', 'id', id)
            const localVarPath = `/machine/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new machine
         * @param {MachinePostRequest} machinePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinePost: async (machinePostRequest: MachinePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'machinePostRequest' is not null or undefined
            assertParamExists('machinePost', 'machinePostRequest', machinePostRequest)
            const localVarPath = `/machine/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineApi - functional programming interface
 * @export
 */
export const MachineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all machines
         * @param {string} [sort] 
         * @param {MachineGetOrderEnum} [order] 
         * @param {MachineGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineGet(sort?: string, order?: MachineGetOrderEnum, direction?: MachineGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get machine by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machineIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new machine
         * @param {MachinePostRequest} machinePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinePost(machinePostRequest: MachinePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinePost(machinePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineApi - factory interface
 * @export
 */
export const MachineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineApiFp(configuration)
    return {
        /**
         * Get all machines
         * @param {string} [sort] 
         * @param {MachineGetOrderEnum} [order] 
         * @param {MachineGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineGet(sort?: string, order?: MachineGetOrderEnum, direction?: MachineGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MachineGet200Response> {
            return localVarFp.machineGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get machine by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MachineIdGet200Response> {
            return localVarFp.machineIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new machine
         * @param {MachinePostRequest} machinePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinePost(machinePostRequest: MachinePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MachinePost200Response> {
            return localVarFp.machinePost(machinePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineApi - object-oriented interface
 * @export
 * @class MachineApi
 * @extends {BaseAPI}
 */
export class MachineApi extends BaseAPI {
    /**
     * Get all machines
     * @param {string} [sort] 
     * @param {MachineGetOrderEnum} [order] 
     * @param {MachineGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machineGet(sort?: string, order?: MachineGetOrderEnum, direction?: MachineGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machineGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get machine by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machineIdGet(id: number, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machineIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new machine
     * @param {MachinePostRequest} machinePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinePost(machinePostRequest: MachinePostRequest, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinePost(machinePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MachineGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MachineGetOrderEnum = typeof MachineGetOrderEnum[keyof typeof MachineGetOrderEnum];
/**
 * @export
 */
export const MachineGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MachineGetDirectionEnum = typeof MachineGetDirectionEnum[keyof typeof MachineGetDirectionEnum];


/**
 * MachineTypeApi - axios parameter creator
 * @export
 */
export const MachineTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all machine types
         * @param {string} [sort] 
         * @param {MachineTypeGetOrderEnum} [order] 
         * @param {MachineTypeGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineTypeGet: async (sort?: string, order?: MachineTypeGetOrderEnum, direction?: MachineTypeGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machine/type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a machine type by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineTypeIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machineTypeIdGet', 'id', id)
            const localVarPath = `/machine/type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a machine type
         * @param {MachineTypePostRequest} machineTypePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineTypePost: async (machineTypePostRequest: MachineTypePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'machineTypePostRequest' is not null or undefined
            assertParamExists('machineTypePost', 'machineTypePostRequest', machineTypePostRequest)
            const localVarPath = `/machine/type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machineTypePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineTypeApi - functional programming interface
 * @export
 */
export const MachineTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all machine types
         * @param {string} [sort] 
         * @param {MachineTypeGetOrderEnum} [order] 
         * @param {MachineTypeGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineTypeGet(sort?: string, order?: MachineTypeGetOrderEnum, direction?: MachineTypeGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineTypeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineTypeGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineTypeApi.machineTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a machine type by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineTypeIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineTypeIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineTypeIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineTypeApi.machineTypeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a machine type
         * @param {MachineTypePostRequest} machineTypePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineTypePost(machineTypePostRequest: MachineTypePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineTypePost(machineTypePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineTypeApi.machineTypePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineTypeApi - factory interface
 * @export
 */
export const MachineTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineTypeApiFp(configuration)
    return {
        /**
         * Get all machine types
         * @param {string} [sort] 
         * @param {MachineTypeGetOrderEnum} [order] 
         * @param {MachineTypeGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineTypeGet(sort?: string, order?: MachineTypeGetOrderEnum, direction?: MachineTypeGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MachineTypeGet200Response> {
            return localVarFp.machineTypeGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a machine type by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineTypeIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MachineTypeIdGet200Response> {
            return localVarFp.machineTypeIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a machine type
         * @param {MachineTypePostRequest} machineTypePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineTypePost(machineTypePostRequest: MachineTypePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.machineTypePost(machineTypePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineTypeApi - object-oriented interface
 * @export
 * @class MachineTypeApi
 * @extends {BaseAPI}
 */
export class MachineTypeApi extends BaseAPI {
    /**
     * Get all machine types
     * @param {string} [sort] 
     * @param {MachineTypeGetOrderEnum} [order] 
     * @param {MachineTypeGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineTypeApi
     */
    public machineTypeGet(sort?: string, order?: MachineTypeGetOrderEnum, direction?: MachineTypeGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MachineTypeApiFp(this.configuration).machineTypeGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a machine type by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineTypeApi
     */
    public machineTypeIdGet(id: number, options?: RawAxiosRequestConfig) {
        return MachineTypeApiFp(this.configuration).machineTypeIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a machine type
     * @param {MachineTypePostRequest} machineTypePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineTypeApi
     */
    public machineTypePost(machineTypePostRequest: MachineTypePostRequest, options?: RawAxiosRequestConfig) {
        return MachineTypeApiFp(this.configuration).machineTypePost(machineTypePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MachineTypeGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MachineTypeGetOrderEnum = typeof MachineTypeGetOrderEnum[keyof typeof MachineTypeGetOrderEnum];
/**
 * @export
 */
export const MachineTypeGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MachineTypeGetDirectionEnum = typeof MachineTypeGetDirectionEnum[keyof typeof MachineTypeGetDirectionEnum];


/**
 * PermissionApi - axios parameter creator
 * @export
 */
export const PermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all permissions
         * @param {string} [sort] 
         * @param {PermissionGetOrderEnum} [order] 
         * @param {PermissionGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionGet: async (sort?: string, order?: PermissionGetOrderEnum, direction?: PermissionGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permission/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a permission by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('permissionIdGet', 'id', id)
            const localVarPath = `/permission/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permission/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all permissions
         * @param {string} [sort] 
         * @param {PermissionGetOrderEnum} [order] 
         * @param {PermissionGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionGet(sort?: string, order?: PermissionGetOrderEnum, direction?: PermissionGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.permissionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a permission by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.permissionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.permissionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionApiFp(configuration)
    return {
        /**
         * Get all permissions
         * @param {string} [sort] 
         * @param {PermissionGetOrderEnum} [order] 
         * @param {PermissionGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionGet(sort?: string, order?: PermissionGetOrderEnum, direction?: PermissionGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PermissionGet200Response> {
            return localVarFp.permissionGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a permission by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PermissionIdGet200Response> {
            return localVarFp.permissionIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionPost(options?: RawAxiosRequestConfig): AxiosPromise<PermissionPost200Response> {
            return localVarFp.permissionPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * Get all permissions
     * @param {string} [sort] 
     * @param {PermissionGetOrderEnum} [order] 
     * @param {PermissionGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public permissionGet(sort?: string, order?: PermissionGetOrderEnum, direction?: PermissionGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).permissionGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a permission by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public permissionIdGet(id: number, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).permissionIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public permissionPost(options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).permissionPost(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PermissionGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PermissionGetOrderEnum = typeof PermissionGetOrderEnum[keyof typeof PermissionGetOrderEnum];
/**
 * @export
 */
export const PermissionGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PermissionGetDirectionEnum = typeof PermissionGetDirectionEnum[keyof typeof PermissionGetDirectionEnum];


/**
 * ReadingApi - axios parameter creator
 * @export
 */
export const ReadingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all readings
         * @param {string} [sort] 
         * @param {ReadingGetOrderEnum} [order] 
         * @param {ReadingGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readingGet: async (sort?: string, order?: ReadingGetOrderEnum, direction?: ReadingGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reading/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reading by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readingIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readingIdGet', 'id', id)
            const localVarPath = `/reading/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a reading
         * @param {ReadingPostRequest} readingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readingPost: async (readingPostRequest: ReadingPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'readingPostRequest' is not null or undefined
            assertParamExists('readingPost', 'readingPostRequest', readingPostRequest)
            const localVarPath = `/reading/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readingPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadingApi - functional programming interface
 * @export
 */
export const ReadingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReadingApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all readings
         * @param {string} [sort] 
         * @param {ReadingGetOrderEnum} [order] 
         * @param {ReadingGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readingGet(sort?: string, order?: ReadingGetOrderEnum, direction?: ReadingGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadingGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readingGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReadingApi.readingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get reading by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readingIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadingIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readingIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReadingApi.readingIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a reading
         * @param {ReadingPostRequest} readingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readingPost(readingPostRequest: ReadingPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readingPost(readingPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReadingApi.readingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReadingApi - factory interface
 * @export
 */
export const ReadingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReadingApiFp(configuration)
    return {
        /**
         * Get all readings
         * @param {string} [sort] 
         * @param {ReadingGetOrderEnum} [order] 
         * @param {ReadingGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readingGet(sort?: string, order?: ReadingGetOrderEnum, direction?: ReadingGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ReadingGet200Response> {
            return localVarFp.readingGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reading by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readingIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ReadingIdGet200Response> {
            return localVarFp.readingIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a reading
         * @param {ReadingPostRequest} readingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readingPost(readingPostRequest: ReadingPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReadingPost200Response> {
            return localVarFp.readingPost(readingPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReadingApi - object-oriented interface
 * @export
 * @class ReadingApi
 * @extends {BaseAPI}
 */
export class ReadingApi extends BaseAPI {
    /**
     * Get all readings
     * @param {string} [sort] 
     * @param {ReadingGetOrderEnum} [order] 
     * @param {ReadingGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadingApi
     */
    public readingGet(sort?: string, order?: ReadingGetOrderEnum, direction?: ReadingGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ReadingApiFp(this.configuration).readingGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reading by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadingApi
     */
    public readingIdGet(id: number, options?: RawAxiosRequestConfig) {
        return ReadingApiFp(this.configuration).readingIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a reading
     * @param {ReadingPostRequest} readingPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadingApi
     */
    public readingPost(readingPostRequest: ReadingPostRequest, options?: RawAxiosRequestConfig) {
        return ReadingApiFp(this.configuration).readingPost(readingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ReadingGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ReadingGetOrderEnum = typeof ReadingGetOrderEnum[keyof typeof ReadingGetOrderEnum];
/**
 * @export
 */
export const ReadingGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ReadingGetDirectionEnum = typeof ReadingGetDirectionEnum[keyof typeof ReadingGetDirectionEnum];


/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all roles
         * @param {string} [sort] 
         * @param {RoleGetOrderEnum} [order] 
         * @param {RoleGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleGet: async (sort?: string, order?: RoleGetOrderEnum, direction?: RoleGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a role by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roleIdGet', 'id', id)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a user role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all roles
         * @param {string} [sort] 
         * @param {RoleGetOrderEnum} [order] 
         * @param {RoleGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleGet(sort?: string, order?: RoleGetOrderEnum, direction?: RoleGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a role by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a user role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.rolePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleApiFp(configuration)
    return {
        /**
         * Get all roles
         * @param {string} [sort] 
         * @param {RoleGetOrderEnum} [order] 
         * @param {RoleGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleGet(sort?: string, order?: RoleGetOrderEnum, direction?: RoleGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleGet200Response> {
            return localVarFp.roleGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a role by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleIdGet200Response> {
            return localVarFp.roleIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a user role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolePost(options?: RawAxiosRequestConfig): AxiosPromise<RolePost200Response> {
            return localVarFp.rolePost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     * Get all roles
     * @param {string} [sort] 
     * @param {RoleGetOrderEnum} [order] 
     * @param {RoleGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleGet(sort?: string, order?: RoleGetOrderEnum, direction?: RoleGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a role by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleIdGet(id: number, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a user role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public rolePost(options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).rolePost(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RoleGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RoleGetOrderEnum = typeof RoleGetOrderEnum[keyof typeof RoleGetOrderEnum];
/**
 * @export
 */
export const RoleGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RoleGetDirectionEnum = typeof RoleGetDirectionEnum[keyof typeof RoleGetDirectionEnum];


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all users
         * @param {string} [sort] 
         * @param {UserGetOrderEnum} [order] 
         * @param {UserGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (sort?: string, order?: UserGetOrderEnum, direction?: UserGetDirectionEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find user using ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userIdGet', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit user
         * @param {number} id 
         * @param {UserIdPutRequest} [userIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdPut: async (id: number, userIdPutRequest?: UserIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userIdPut', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add role to user
         * @param {UserRolePostRequest} userRolePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRolePost: async (userRolePostRequest: UserRolePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRolePostRequest' is not null or undefined
            assertParamExists('userRolePost', 'userRolePostRequest', userRolePostRequest)
            const localVarPath = `/user/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRolePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all users
         * @param {string} [sort] 
         * @param {UserGetOrderEnum} [order] 
         * @param {UserGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(sort?: string, order?: UserGetOrderEnum, direction?: UserGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(sort, order, direction, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find user using ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit user
         * @param {number} id 
         * @param {UserIdPutRequest} [userIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userIdPut(id: number, userIdPutRequest?: UserIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userIdPut(id, userIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add role to user
         * @param {UserRolePostRequest} userRolePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRolePost(userRolePostRequest: UserRolePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRolePost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRolePost(userRolePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userRolePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get all users
         * @param {string} [sort] 
         * @param {UserGetOrderEnum} [order] 
         * @param {UserGetDirectionEnum} [direction] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(sort?: string, order?: UserGetOrderEnum, direction?: UserGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGet200Response> {
            return localVarFp.userGet(sort, order, direction, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Find user using ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<UserIdGet200Response> {
            return localVarFp.userIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit user
         * @param {number} id 
         * @param {UserIdPutRequest} [userIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdPut(id: number, userIdPutRequest?: UserIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserIdGet200Response> {
            return localVarFp.userIdPut(id, userIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add role to user
         * @param {UserRolePostRequest} userRolePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRolePost(userRolePostRequest: UserRolePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserRolePost201Response> {
            return localVarFp.userRolePost(userRolePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get all users
     * @param {string} [sort] 
     * @param {UserGetOrderEnum} [order] 
     * @param {UserGetDirectionEnum} [direction] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(sort?: string, order?: UserGetOrderEnum, direction?: UserGetDirectionEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userGet(sort, order, direction, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find user using ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userIdGet(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit user
     * @param {number} id 
     * @param {UserIdPutRequest} [userIdPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userIdPut(id: number, userIdPutRequest?: UserIdPutRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userIdPut(id, userIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add role to user
     * @param {UserRolePostRequest} userRolePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userRolePost(userRolePostRequest: UserRolePostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userRolePost(userRolePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type UserGetOrderEnum = typeof UserGetOrderEnum[keyof typeof UserGetOrderEnum];
/**
 * @export
 */
export const UserGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type UserGetDirectionEnum = typeof UserGetDirectionEnum[keyof typeof UserGetDirectionEnum];


